<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>MR BEAST</title>
<style>
#plot{
    width: 100%;
    height: 100%
}
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/3.0.3/plotly.min.js"></script>
<div id="plot"></div>
<div id = "finalOdds">

</div>

<form id="form">
    <label for="time">Time (hours)</label><br>
    <input type="number" id="time" step = "any" value = "24"><br><br>

    <label for="views">Views:</label><br>
    <input type="number" id="views" value = "50000000"><br><br>

    <label for="date">Release Date:</label><br>
    <input type="date" id="date" value = "2025-08-02"><br><br>
    <input type="submit" value="Submit">
</form>
<script>

let releaseDate = new Date(2025, 7, 2)
function timeToPercent(x){
    let L = 65.98606209690959
    let d = 32.372082402569404
    let k = 0.06287719939252132
    let x0 = -5.398947976847045
    let e = Math.E
    return (L*e**(-1*e**(-k*(x-x0))) - d)/24
}

function timeToSpreads(x){
    let a = 1.5085534391508881
    let b = 10.310613572906199
        
    return ((x*(24-x))**(1/a)*1/b)/100
}

function beta(time, min, max){
    if (min <0){
        min = 0
    }
    if (max > 1){
        max = 1
    }
    if (min > 1){
        return 0
    }
    if (time === 0){
        if (min === 0){
            return 1
        }
        return 0
    }
    if (time === 24){
        if (max === 1){
            return 1
        }
        return 0
    }
    let k_0 = timeToSpreads(time)**2
    let j = timeToPercent(time)
    let r_0 = (1-j)/j
    let alpha = (r_0/((1+r_0)**2)-k_0)/(k_0*(1+r_0))
    let beta = r_0*alpha
    function inputBeta(x){
        return (x)**(alpha-1)*(1-x)**(beta-1)
    }
    let o = integrate(inputBeta, 0, 1)
    let a = integrate(inputBeta, min, max)
    return a/o
}

let daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
function dayToExpectedViews(date){
    let year = date.getFullYear()
    let month = date.getMonth()
    let day = date.getDate()

    let daysSinceStartOf2024 = 0;

    daysSinceStartOf2024 += (year-2023)*365;
    for (let i = 0; i < month; i++) {
        daysSinceStartOf2024 += daysInMonth[i]
    }
    daysSinceStartOf2024 += day
    let x = daysSinceStartOf2024/10
    if (x>36.5){
        x -= Math.floor(x/36.5)*36.5
    }
    let r = 5.533539198666395
    let j = 1.4329421112986238
    let n = 42.31389387556744
    return r*Math.cos(x*2*Math.PI/36.5 - Math.PI*j) + n
}
function initialDistrib(min, max){
    let m = Math.log(dayToExpectedViews(releaseDate));
    let s = 0.19817992849970043;

    function inputLogNormal(x){
        return 1/(s*Math.sqrt(2*Math.PI))*1/x*Math.E**(-1*(Math.log(x)-m)**2/(2*s**2))
    }
    return integrate(inputLogNormal, min, max)
}

function integrate(func, min, max){
    let n = 1_00_000;
    let sum = 0
    let width = (max-min)/n
    for (let i = 0; i <= n; i++) {
        let x = min+width*i
        let multiplier;
        if (i === 0 || i===n){
            multiplier = 1
        } else if (i%2 === 1){
            multiplier = 4
        } else{
            multiplier = 2
        }
        sum+=multiplier*func(x)*width/3
    }
    return sum
}
let time = 0;
let numViews = 0;
let minViews = 10;
let maxViews = 110;

let brackets = [
    [minViews, 30],
    [30, 35],
    [35, 40],
    [40, 45],
    [45, 50],
    [50, 55],
    [55, maxViews]
]
let bracketedResults = []
function calcOdds(){
    let possibilities = [];
    let bucketSize = 0.05
    for (let i = minViews; i < maxViews; i+=bucketSize) {
        
        let prior = initialDistrib(i, i+bucketSize)
        multiplier = 1/((i+bucketSize/2)*1_000_000)
        let betaResult = beta(time, (numViews*0.999)*multiplier, (numViews*1.001)*multiplier)
        possibilities.push(prior*betaResult)

    }
    let totalp = 0
    for (let i = 0; i < possibilities.length; i++) {
        totalp+=possibilities[i]
    }
    for (let i = 0; i < possibilities.length; i++) {
        possibilities[i] = possibilities[i]/totalp
    }

    let lumpedPossibilities = []

    let sums = 0
    let mod = 5/bucketSize
    for (let i = 0; i < possibilities.length; i++) {
        sums += possibilities[i]
        if (i%mod === mod-1){
            lumpedPossibilities.push([(i-mod+1)*bucketSize+minViews, (i+1)*bucketSize+minViews, sums])
            sums = 0
        }
    }
    bracketedResults = [];
    for (let i = 0; i < brackets.length; i++) {
        bracketedResults.push(0)
    }
    console.log(lumpedPossibilities)
    for (let i = 0; i < lumpedPossibilities.length; i++) {
        let lumpedPossi = lumpedPossibilities[i];
        let lumpedPossiMin = lumpedPossi[0];
        let lumpedPossiMax = lumpedPossi[1];
        let lumpedPossiOdds = lumpedPossi[2];
        for (let j = 0; j < brackets.length; j++) {
            let bracket = brackets[j]
            let bracketMin = bracket[0];
            let bracketMax = bracket[1];
            if (lumpedPossiMin >= bracketMin && lumpedPossiMax <= bracketMax){
                bracketedResults[j] += lumpedPossiOdds
                break
            }
        }
    }

    let container = document.getElementById("finalOdds");
    container.innerHTML = ""
    for (let i = 0; i < brackets.length; i++) {
        let bracketMin = brackets[i][0]
        let bracketMax = brackets[i][1];
        let text = ("Min: " + bracketMin + " Max: " + bracketMax + " <strong>" + Math.round(bracketedResults[i]*1000)/10 + "%</strong>")
        let newElement = document.createElement("p");
        newElement.innerHTML = text
        container.appendChild(newElement)
    }

    let x1 = [];
    let y1 = [];
    let x2 = [];
    let y2 = [];
    for (let i = 0; i < possibilities.length; i += 1) {
        x1.push(i*bucketSize+minViews+bucketSize/2);
        y1.push(possibilities[i]*100);
    }
    
    for (let i = 0; i < Math.round(possibilities.length/5*bucketSize); i += 1) {
        x2.push(i*5+minViews+2.5);
        y2.push(lumpedPossibilities[i][2]*100);
    }

    Plotly.newPlot('plot', 
        [
            {
                x: x1,
                y: y1,
                type: 'scatter',
                mode: 'lines',
                name: 'Odds'
            },
            {
                x: x2,
                y: y2,
                type: 'scatter',
                mode: 'lines',
                name: 'Odds (bucketed)'
            }
        ]
    );
}



let form = document.getElementById('form');

form.addEventListener('submit', function(event) {
    event.preventDefault(); // Prevent page reload
    time = Number(document.getElementById("time").value)
    numViews = Number(document.getElementById("views").value)
    releaseDate = new Date(document.getElementById("date").value)
    calcOdds()
    audio.play();
});

//music
let playlist = [
  "Ahrix%20-%20Nova%20[NCS%20Release].mp3",
  "Elektronomia%20-%20Sky%20High%20[NCS%20Release].mp3",
  "Lost%20Sky%20-%20Dreams%20[NCS%20Release].mp3",
  "Tobu%20-%20Colors.mp3",
  "Unity%20Instrumental.mp3"
];
let currentSong = Math.floor(Math.random()*playlist.length);
let audio = new Audio(playlist[currentSong]);
audio.addEventListener("ended", function() {
    currentSong = (currentSong + 1) % playlist.length;
    audio.src = playlist[currentSong];
    audio.play();
});
</script>
</body>
</html>